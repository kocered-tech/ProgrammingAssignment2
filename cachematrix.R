## Put comments here that give an overall description of what your
## functions do

## following function creates

## This awesome function allows you to create a special kind of "matrix" object that can remember its inverse for later use. You know how sometimes you have to calculate the inverse of a matrix multiple times? Well, this function takes care of that by storing the inverse in a cache. This clever feature makes your matrix operations faster and more efficient because you can simply retrieve the pre-calculated inverse whenever you need it. 

makeCacheMatrix <- function(x = matrix()) {
		# Create a caching function that outputs a list
        inv = NULL
        set <- function(y){
        x <<- y
        inv <<- NULL
        }
        get <- function(){x}
        setInverse <- function(inverse){inv <<- inverse}
        getInverse <- function(){inv}
        list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}


##The function presented here performs the computation of the inverse for the unique "matrix" object generated by the preceding makeCacheMatrix function. Remember that cool matrix object we created earlier? Well, this function takes it to the next level by calculating its inverse for you. No need to worry about the complex calculations involved because this function simplifies the process. Just pass in your special matrix, and voila! You'll receive the inverse with ease. 

cacheSolve <- function(x, ...) {
        ## Return the inverse of X
        inv <- x$getInverse()
        if(!is.null(inv)){
        message("getting inverse data")
        return(inv)
        }
        mat <- x$get()
        inv <- solve(mat, ...)
        x$setInverse(inv)
        inv
}

# Create a matrix using makeCacheMatrix
matrixObject <- makeCacheMatrix(matrix(c(1, 2, 3, 4), nrow = 2))

# Compute the inverse using cacheSolve
inverseMatrix <- cacheSolve(matrixObject)

# Print the inverse matrix
print(inverseMatrix)
